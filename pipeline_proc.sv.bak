module pipelined_proc(input  logic 			clk, reset, enable,
							output logic InstrD, //output to external controller
							input logic RegWriteD, MemtoRegD, //controller inputs
							input logic MemWriteD, 
							input logic [2:0] ALUControlD,
							input logic ALUSrcD, 
							input logic RegDstD,
							input logic BranchD,
							output logic [31:0] PCF, //output to instr mem
							input logic [31:0] InstrF, //instruction input
							output logic [31:0] ALUOutM, WriteDataM, //Output to data mem
							output logic MemWriteM,
							input logic [31:0] ReadDataM); //word read from data mem
					 
	//This is the pipelined processor.
	//The memories and controller are external,
	//so we have to send data in / out to them.
	//The controller inputs come in at the "decode" stage.
	
	//Sections:
	//1. Signal definitions.
	//2. Module definitions.
	
	//Signal list - grouped by fetch, decode, execute, memory, writeback.
	logic [31:0] PC;

	//Fetch (F):

	logic [31:0] PCPlus4F;
	logic [31:0] PCF;
	logic [31:0] InstrF;
	
	
	logic StallF;
	
	//Decode (D) suffix

	//Datapath:
	logic [31:0] InstrD;
	logic [31:0] RD1D, RD1D_muxed;
	logic [31:0] RD2D, RD2D_muxed;
	logic [31:0] SignImmD, SignImmDls2;
	logic [31:0] PCPlus4D;
	logic [31:0] PCBranchD;
	logic EqualD;
	logic [4:0] RsD, RtD, RdD;

	//Controller signals:
	logic RegWriteD;
	logic MemtoRegD;
	logic MemWriteD;
	logic [2:0] ALUControlD;
	logic ALUSrcD;
	logic RegDstD;
	logic BranchD;
	logic PCSrcD;
	
	//Execute (E) Suffix:
	
	//Datapath:
	logic [31:0] RD1E; 
	logic [31:0] RD2E;
	logic [4:0] RsE;
	logic [4:0] RtE;
	logic [4:0] RdE;
	logic [4:0] WriteRegE;
	logic [31:0] SrcAE; 
	logic [31:0] SrcBE;
	logic [31:0] WriteDataE;
	logic [31:0] SignImmE;
	logic [31:0] AluOutE;
	
	//Controller
	logic RegWriteE;
	logic MemtoRegE;
	logic MemWriteE;
	logic [2:0] ALUControlE;
	logic ALUSrcE;
	logic RegDstE;
	
	//Memory stage (M)
	//Datapath
	logic [31:0] ALUOutM;
	logic [31:0] WriteDataM;
	logic [4:0] WriteRegM;
	logic [31:0] ReadDataM;
	
	//Controller
	logic RegWriteM;
	logic MemtoRegM;
	logic MemWriteM;
	
	//Writeback Stage (W)
	//Datapath
	logic [31:0] ReadDataW;
	logic [31:0] ALUOutW;
	logic [4:0] WriteRegW;
	logic [31:0] ResultW;
	
	//Controller
	logic RegWriteW;
	logic MemtoRegW;
	
	
	//Organize this into the pipelined sections.
	//From left to right:
	
	//Fetch (F)
	
		//FF with clear.
		//TODO: Convert to enable for pipelined.
		flopr #(32) pcreg(clk, reset, PC, PCF);
	
		//imemory IS EXTERNAL.
//		imem instr_mem(clk, PCF, InstrF);
		
		//TODO: Controller signals pipelining.
		
		
	// Decode (D)
	
		//TODO: Convert to clear / enable for pipelined.
		flopr #(32) Dreg_inst(clk, reset, InstrF, InstrD);
		flopr #(32) Dreg_pcpl(clk, reset, PCPlus4F, PCPlus4D);
		
		//Register file
		regfile rf(clk, reset, 
					  RegWriteW,
					  InstrD[25:21],
					  InstrD[20:16],
					  WriteRegW,
					  ResultW,
					  RD1D,
					  RD2D);
					  
		//RF rd output muxes
		//TODO: Adjust s signal to be from hazard unit.
		mux2 #(32) rd1_mux2(RD1D, ALUOutM, 1'b0, RD1D_muxed);
		mux2 #(32) rd2_mux2(RD2D, ALUOutM, 1'b0, RD2D_muxed);
		
		assign PCSrcD = BranchD & (RD1D_muxed == RD2D_muxed);
		
		//Sign Immediate extension.
		signext signext_imm(InstrD[15:0], SignImmD);
		
		ls2 ls2_SignExtImm(SignImmD, SignImmDls2);
		
		adder add_PC_SignImmExt(SigmImmDls2, PCPlus4D);
		
		//TODO: Controller signals pipelining.
		//Note: the controller inputs are already in the D stage.
		
		
	//Execute (E)
	
		//TODO: Convert to hazard enabled FFs.
		flopr #(32) flopr_E_RD1D(clk, reset, RD1D_muxed, RD1E);
		flopr #(32) flopr_E_RD2D(clk, reset, RD2D_muxed, RD2E);
		
		flopr #(5) flopr_rsE(clk, reset, RsD, RsE);
		flopr #(5) flopr_rtE(clk, reset, RtD, RtE);
		flopr #(5) flopr_rdE(clk, reset, RdD, RdE);
		
		flopr #(32) flopr_SignImmE(clk, reset, SignImmD, SignImmE);
		
		//Rt vs Rd mux.
		mux2 #(5) mux2_Rt_Rs(RtE, RdE, RegDstE, WriteRegE);
		
		//Muxes for hazard control. Set to always pass the RD1, RD2 values for now.
		//TODO: update with control signals and FF for hazards.
		mux3 #(32) mux3_RD1_ResultW_ALUOutM(2'b00, RD1E, ResultW, ALUOutM, SrcAE);
		mux3 #(32) mux3_RD2_ResultW_ALUOutM(2'b00, RD2E, ResultW, ALUOutM, SrcBE);
		
		//ALU unit
		//Leave "cout" and "zero" disconnected for now.
		alu_32bit alu(SrcAE, SrcBE, ALUControlE, ALUOutE, , );
		
		//TODO: Controller signals pipelining.
		
	// Memory (M)
		
		//TODO: convert to hazard enabled FFs.
		flopr #(32) flopr_M_ALUOut(clk, reset, ALUOutE, ALUOutM);
		flopr #(32) flopr_M_WriteDataM(clk, reset, WriteDataE, WRiteDataM);
		flopr #(32) flopr_M_WriteReg(clk, reset, WriteRegE, WriteRegM);
		
		//Data memory is external -- commented out.
//		dmem data_mem(clk, MemWriteM, ALUOutM, WriteDataM, ReadDataM);
	
		//TODO: Controller signals pipelining.
		
		
	//Writeback (W)
		
		//TODO: Convert to hazard FFs.
		flopr #(32) flopr_W_readData(clk, reset, ReadDataM, ReadDataW);
		flopr #(32) flopr_W_ALUOut(clk, reset, ALUOutM, ALUOutW);
		
		mux2 #(32) mux2_W_ALU_ReadDataW(clk, reset, ALUOutW, ReadDataW, MemtoRegW, ResultW);
	
		
		//TODO: Controller signals pipelining.

endmodule